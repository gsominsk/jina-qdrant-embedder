# Индексация кодовой базы с помощью пользовательских эмбеддингов

Этот проект настраивает локальное окружение для индексации кода с использованием пользовательского сервиса эмбеддингов и векторной базы данных Qdrant.

## Обзор системы

Система состоит из двух основных сервисов, управляемых с помощью Docker Compose:

1.  **Qdrant:** Векторная база данных, используемая для хранения и поиска эмбеддингов кода. Она работает в собственном контейнере и предоставляет свой API на порту `6333`.
2.  **Сервис эмбеддингов:** Пользовательское, легковесное FastAPI-приложение, которое обслуживает модель `jina-code-v2`. Оно использует библиотеку `transformers` для генерации эмбеддингов и предоставляет OpenAI-совместимый API на порту `4000`.

## Как это работает

1.  **Конфигурация Roo Code:**
    *   Указывает `embeddingProvider` на `baseUrl` пользовательского сервиса: `http://localhost:4000/v1`.
    *   Указывает `vectorStore` как `qdrant` и предоставляет его URL: `http://localhost:6333`.

    Ниже приведен пример полного, валидного конфигурационного файла:

    ```json
    {
      "embeddingProvider": "openai",
      "baseUrl": "http://localhost:4000/v1",
      "modelId": "jina-code-v2",
      "embeddingDimension": 768,
      "vectorStore": "qdrant",
      "qdrantUrl": "http://localhost:6333"
    }
    ```

2.  **Генерация эмбеддингов:** Когда Roo Code необходимо сгенерировать эмбеддинг для фрагмента кода, он отправляет запрос на `http://localhost:4000/v1/embeddings`.

3.  **Пользовательский сервис (`embeddings/jina-server`):** Приложение FastAPI получает запрос, использует модель `jinaai/jina-embeddings-v2-base-code` для генерации векторного эмбеддинга и возвращает его в формате, имитирующем API OpenAI.

4.  **Хранение векторов:** Затем Roo Code берет этот эмбеддинг и сохраняет его в локально запущенной базе данных Qdrant.

## Как запустить

Сервисы управляются двумя отдельными файлами `docker-compose.yml`. Для полной работоспособности системы необходимо запустить оба.

1.  **Запуск базы данных Qdrant:**
    Откройте терминал и выполните следующую команду из корневого каталога проекта:
    ```bash
    docker-compose -f qdrant/docker-compose.yml up -d
    ```
    Это запустит контейнер Qdrant и откроет доступ к его сервису на порту `6333`.

2.  **Запуск сервиса эмбеддингов:**
    В другом терминале выполните следующую команду из корневого каталога проекта:
    ```bash
    docker-compose -f embeddings/docker-compose.yml up -d
    ```
    Это соберет и запустит пользовательское приложение FastAPI. Сервис будет доступен на порту `4000`.

После запуска обоих сервисов система готова к использованию Roo Code.

## Глубокая отладка и оптимизация производительности

В ходе интенсивного использования сервиса была выявлена критическая проблема нестабильности: под нагрузкой контейнер `jina-openai` аварийно завершал работу из-за нехватки оперативной памяти (OOM Kill), что приводило к таймаутам и отказам в обслуживании.

Детальное расследование выявило **две независимые утечки памяти**. Ниже описан пошаговый процесс их обнаружения и устранения.

### Этап 1: Инструментарий и диагностика

Для точного анализа в код приложения (`embeddings/app/app.py`) были временно добавлены инструменты профилирования:
1.  **Мониторинг памяти с `psutil`:** Для логирования потребления физической памяти (RSS) в реальном времени.
2.  **Профилирование с `tracemalloc`:** Для отслеживания объектов Python, которые выделяют память и не освобождаются.

Первичный нагрузочный тест подтвердил наличие быстрой утечки, после чего значение семафора (`SEMAPHORE_VALUE`) было временно снижено с `8` до `2` для изоляции проблемы.

### Этап 2: Устранение критической утечки (PyTorch Tensors)

Анализ логов `tracemalloc` показал, что память стремительно утекала из-за тензоров PyTorch, которые не освобождались после обработки каждого батча. Сборщик мусора Python не мог автоматически очистить память, занятую на GPU.

**Решение:**
В код обработки была добавлена явная очистка ресурсов после их использования.

```python
# embeddings/app/app.py
# ... внутри функции кодирования ...
del batch_embeddings
del tokens
torch.cuda.empty_cache()
```
Этот шаг полностью устранил быструю утечку, но осталась вторая, более медленная.

### Этап 3: Устранение медленной утечки (FastAPI/Starlette)

После устранения основной проблемы `tracemalloc` указал на новую причину: объекты, связанные с жизненным циклом запроса-ответа в фреймворках FastAPI и Starlette. Эти объекты не всегда корректно убирались сборщиком мусора в асинхронной среде.

**Решение:**
Был внедрен глобальный `middleware`, который принудительно запускает сборщик мусора (`gc.collect()`) после завершения каждого HTTP-запроса.

```python
# embeddings/app/app.py
import gc
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def garbage_collector_middleware(request: Request, call_next):
    response = await call_next(request)
    gc.collect()
    return response
```
Это решение полностью устранило вторую утечку.

### Этап 4: Финальная настройка производительности

После полного устранения обеих утечек последним шагом было восстановление исходной производительности.

**Решение:**
Значение семафора было возвращено к оптимальному значению `8`, рассчитанному исходя из доступной RAM.

```python
# embeddings/app/app.py
SEMAPHORE_VALUE = 8
```

### Итоговый результат

В результате проделанной работы сервис был полностью стабилизирован.
-   **Утечки памяти устранены:** Потребление RAM находится под контролем.
-   **Производительность оптимальна:** Система эффективно использует ресурсы CPU.
-   **Стабильность:** Сервис успешно справляется с высокой нагрузкой без сбоев.

Финальное тестирование показало, что при значении семафора `8` потребление памяти колеблется в безопасном диапазоне 3-5 ГБ.

## Интеграция с Visual Studio Code

Для максимального удобства проект настроен для управления прямо из VS Code с помощью горячих клавиш. Для этого необходимо настроить два файла в конфигурации VS Code.

### 1. Настройка задач (`tasks.json`)

Создайте или обновите файл `tasks.json` в вашей пользовательской директории настроек VS Code.

*   **Путь на macOS:** `~/Library/Application Support/Code/User/tasks.json`
*   **Путь на Windows:** `%APPDATA%\Code\User\tasks.json`
*   **Путь на Linux:** `~/.config/Code/User/tasks.json`

Вставьте в него следующее содержимое, **обязательно заменив** `$HOME/sandbox/mcp` на актуальный путь к вашему проекту:

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "startall + warmup",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "start", "all"]
    },
    {
      "label": "stopall",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "stop", "all"]
    },
    {
      "label": "restartall",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "restart", "all"]
    },
    {
      "label": "qdrant restart",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "restart", "qdrant"]
    },
    {
      "label": "jina start + warmup",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "start", "jina"]
    },
    {
      "label": "jina stop",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "stop", "jina"]
    },
    {
      "label": "help: embeddings shortcuts",
      "type": "shell",
      "command": "echo",
      "args": [
        "-e",
        "\\033[1mJina/Qdrant — горячие клавиши\\033[0m\\n\\n  ⌘⇧9   startall + warmup      — Запустить Qdrant, Jina и прогреть эмбеддинги\\n  ⌘⇧=   restartall            — Перезапустить все сервисы\\n  ⌘⇧0   help: embeddings shortcuts  — Показать этот экран\\n  ⌘⇧-   stopall               — Остановить Jina и Qdrant\\n  ⌘⇧8   qdrant restart        — Перезапустить Qdrant\\n  ⌘⇧7   jina start + warmup   — Запустить Jina и прогреть\\n  ⌘⇧6   jina stop             — Остановить Jina\\n\\nПодсказка: команды настраиваются в User Tasks и Keyboard Shortcuts (JSON)."
      ],
      "presentation": {
        "reveal": "always",
        "panel": "dedicated",
        "clear": true
      },
      "problemMatcher": []
    }
  ]
}
```

### 2. Настройка горячих клавиш (`keybindings.json`)

Аналогично, создайте или обновите файл `keybindings.json`.

*   **Путь на macOS:** `~/Library/Application Support/Code/User/keybindings.json`
*   **Путь на Windows:** `%APPDATA%\Code\User\keybindings.json`
*   **Путь на Linux:** `~/.config/Code/User/keybindings.json`

Вставьте в него следующее содержимое:

```json
[
  {
    "key": "cmd+shift+9",
    "command": "workbench.action.tasks.runTask",
    "args": "startall + warmup"
  },
  {
    "key": "cmd+shift+=",
    "command": "workbench.action.tasks.runTask",
    "args": "restartall"
  },
  {
    "key": "cmd+shift+0",
    "command": "workbench.action.tasks.runTask",
    "args": "help: embeddings shortcuts"
  },
  {
    "key": "cmd+shift+-",
    "command": "workbench.action.tasks.runTask",
    "args": "stopall"
  },
  {
    "key": "cmd+shift+8",
    "command": "workbench.action.tasks.runTask",
    "args": "qdrant restart"
  },
  {
    "key": "cmd+shift+7",
    "command": "workbench.action.tasks.runTask",
    "args": "jina start + warmup"
  },
  {
    "key": "cmd+shift+6",
    "command": "workbench.action.tasks.runTask",
    "args": "jina stop"
  }
]
```

### Доступные команды (горячие клавиши)

После настройки вы сможете управлять сервисами с помощью следующих сочетаний клавиш (для macOS, замените `cmd` на `ctrl` для Windows/Linux):

| Горячая клавиша | Команда                  | Описание                                           |
| --------------- | ------------------------ | -------------------------------------------------- |
| `⌘ + ⇧ + 9`     | `startall + warmup`      | Запустить Qdrant, Jina и прогреть эмбеддинги        |
| `⌘ + ⇧ + =`     | `restartall`             | Перезапустить все сервисы                          |
| `⌘ + ⇧ + -`     | `stopall`                | Остановить Jina и Qdrant                           |
| `⌘ + ⇧ + 8`     | `qdrant restart`         | Перезапустить только Qdrant                        |
| `⌘ + ⇧ + 7`     | `jina start + warmup`    | Запустить только Jina и прогреть                    |
| `⌘ + ⇧ + 6`     | `jina stop`              | Остановить только Jina                             |
| `⌘ + ⇧ + 0`     | `help: embeddings shortcuts` | Показать эту справку в терминале VS Code           |

## Диаграмма архитектуры

Простая ASCII-диаграмма, иллюстрирующая поток данных:

```
+--------------------------+
|      Клиент Roo Code     |
| (в вашем IDE, настроен   |
| через roo-code-config.json)|
+--------------------------+
           |
           | 1. POST-запрос кода для эмбеддинга
           v
+--------------------------+
|  Пользовательский сервис |
|       FastAPI            |
|  (Docker, Порт 4000)     |
|--------------------------|
|   |                      |
|   | 2. Обработка с ...   |
|   v                      |
| +--------------------+   |
| |   Модель jina-code-v2  |   |
| +--------------------+   |
|   ^                      |
|   | 3. Возврат вектора   |
|   |                      |
+--------------------------+
           |
           | 4. Возврат OpenAI-совместимого эмбеддинга
           v
+--------------------------+
|      Клиент Roo Code     |
| (получает эмбеддинг)     |
+--------------------------+
           |
           | 5. Сохранение эмбеддинга в...
           v
+--------------------------+
|    Векторная БД Qdrant   |
|    (Docker, Порт 6333)   |
+--------------------------+
```

### Объяснение потока данных:

1.  **Roo Code -> FastAPI:** Ваше IDE, используя настройки из `roo-code-config.json`, отправляет фрагмент кода в пользовательский сервис FastAPI на порт `4000`.
2.  **FastAPI -> Модель:** Сервис FastAPI (прослойка) принимает код и передает его модели `jina-code-v2`, которая работает в том же контейнере.
3.  **Модель -> FastAPI:** Модель преобразует код в числовой вектор (эмбеддинг) и отправляет его обратно в сервис.
4.  **FastAPI -> Roo Code:** Сервис оборачивает этот вектор в стандартный JSON-формат и отправляет его обратно в ваше IDE.
5.  **Roo Code -> Qdrant:** Ваше IDE получает эмбеддинг и отправляет его в базу данных Qdrant на порт `6333`, где он сохраняется и индексируется для будущих поисков.