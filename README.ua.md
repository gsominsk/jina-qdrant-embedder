# Індексація кодової бази за допомогою користувацьких ембедингів

Цей проєкт налаштовує локальне оточення для індексації коду з використанням користувацького сервісу ембедингів та векторної бази даних Qdrant.

## Огляд системи

Система складається з двох основних сервісів, керованих за допомогою Docker Compose:

1.  **Qdrant:** Векторна база даних, що використовується для зберігання та пошуку ембедингів коду. Вона працює у власному контейнері та надає свій API на порту `6333`.
2.  **Сервіс ембедингів:** Користувацький, легковий FastAPI-додаток, що обслуговує модель `jina-code-v2`. Він використовує бібліотеку `transformers` для генерації ембедингів та надає OpenAI-сумісний API на порту `4000`.


## Діаграма архітектури

Проста ASCII-діаграма, що ілюструє потік даних:

```
+---------------------------------+
|        Клієнт Roo Code          |
| (у вашому IDE, налаштований через|
|  roo-code-config.json)          |
+---------------------------------+
            |
            | 1. POST-запит коду для ембединга
            v
+---------------------------------+
|    Користувацький сервіс        |
|    FastAPI (Docker, Порт 4000)  |
|---------------------------------|
|   |        Health: /health      |
|   | 2. Обробка з ...            |
|   v                             |
| +-----------------------------+ |
| | jinaai/jina-embeddings-v2-  | |
| | base-code Модель            | |
| +-----------------------------+ |
|   ^                             |
|   | 3. Повернення вектора        |
|   |                             |
+---------------------------------+
            |
            | 4. Повернення OpenAI-сумісного ембединга
            v
+---------------------------------+
|        Клієнт Roo Code          |
|    (отримує ембединг)            |
+---------------------------------+
            |
            | 5. Збереження ембединга в...
            v
+---------------------------------+
|      Векторна БД Qdrant         |
|      (Docker, Порт 6333)        |
|      Health: /collections       |
+---------------------------------+

Сервіс прогріву: Ініціалізує модель при запуску
```

### Пояснення потоку даних:

1.  **Roo Code -> FastAPI:** Ваше IDE, використовуючи налаштування з `roo-code-config.json`, надсилає фрагмент коду в користувацький сервіс FastAPI на порт `4000`.
2.  **FastAPI -> Модель:** Сервіс FastAPI (прошарок) приймає код і передає його моделі `jinaai/jina-embeddings-v2-base-code`, яка працює в тому ж контейнері.
3.  **Модель -> FastAPI:** Модель перетворює код на числовий вектор (ембединг) і надсилає його назад у сервіс.
4.  **FastAPI -> Roo Code:** Сервіс обгортає цей вектор у стандартний JSON-формат і надсилає його назад у ваше IDE.
5.  **Roo Code -> Qdrant:** Ваше IDE отримує ембединг і надсилає його в базу даних Qdrant на порт `6333`, де він зберігається та індексується для майбутніх пошуків.

**Додаткові сервіси:**
- **Сервіс прогріву:** Автоматично ініціалізує модель при запуску контейнера, надсилаючи тестовий запит.
- **Перевірки здоров'я:** Обидва сервіси надають ендпоінти для моніторингу доступності (`/health` для ембедингів, `/collections` для Qdrant).

## Як це працює

1.  **Конфігурація Roo Code:**
    *   Вказує `embeddingProvider` на `baseUrl` користувацького сервісу: `http://localhost:4000/v1`.
    *   Вказує `vectorStore` як `qdrant` та надає його URL: `http://localhost:6333`.

    Нижче наведено приклад повного, валідного конфігураційного файлу:

    ```json
    {
      "embeddingProvider": "openai",
      "baseUrl": "http://localhost:4000/v1",
      "modelId": "jinaai/jina-embeddings-v2-base-code",
      "embeddingDimension": 768,
      "vectorStore": "qdrant",
      "qdrantUrl": "http://localhost:6333"
    }
    ```

2.  **Генерація ембедингів:** Коли Roo Code необхідно згенерувати ембединг для фрагмента коду, він надсилає запит на `http://localhost:4000/v1/embeddings`.

3.  **Користувацький сервіс (`embeddings/jina-server`):** Додаток FastAPI отримує запит, використовує модель `jinaai/jina-embeddings-v2-base-code` для генерації векторного ембединга та повертає його у форматі, що імітує API OpenAI.

4.  **Зберігання векторів:** Потім Roo Code бере цей ембединг і зберігає його в локально запущеній базі даних Qdrant.

## Як запустити

Цей проєкт пропонує два основних методи запуску сервісів залежно від вашої операційної системи та вимог до продуктивності. Всі операції централізовані через скрипт `./scripts/manage.sh`.

### Варіант 1: Оточення на базі Docker (CPU / CUDA)

Це універсальний, кросплатформний метод. Він ідеальний для стандартної розробки на будь-якій ОС та для виробничих середовищ, особливо з GPU NVIDIA, оскільки Docker може використовувати CUDA для прискорення.

-   **Запуск всіх сервісів:**
    ```bash
    ./scripts/manage.sh start all
    ```

-   **Зупинка всіх сервісів:**
    ```bash
    ./scripts/manage.sh stop all
    ```

-   **Перезапуск всіх сервісів:**
    ```bash
    ./scripts/manage.sh restart all
    ```

### Варіант 2: Гібридне оточення для macOS (GPU Apple Silicon)

Це спеціалізована, високопродуктивна настройка для розробників на **macOS з Apple Silicon (M1/M2/M3)**. Вона необхідна, оскільки Docker на macOS не може отримати доступ до GPU хоста (MPS). Цей гібридний підхід запускає критично важливий сервіс `embeddings` нативно на хості для повного використання GPU, в той час як база даних `qdrant` продовжує працювати зручно в Docker.

#### Попередні вимоги

У вас повинні бути встановлені [pyenv](https://github.com/pyenv/pyenv#installation) та [tmux](https://github.com/tmux/tmux/wiki/Installing) через Homebrew:
```bash
brew install pyenv tmux
```

#### Одноразова настройка

Перед першим запуском підготуйте локальне оточення Python однією командою:
```bash
./scripts/manage.sh local setup
```
Цей скрипт автоматизує:
1.  Встановлення правильної версії Python через `pyenv`.
2.  Створення локального віртуального оточення (`./venv`).
3.  Встановлення всіх необхідних залежностей Python.

#### Запуск гібридного оточення

1.  **Запуск Qdrant (у Docker):**
    ```bash
    ./scripts/manage.sh start qdrant
    ```

2.  **Запуск сервісу ембедингів (локально на macOS):**
    ```bash
    ./scripts/manage.sh local start
    ```
    Це запустить сервіс у фоновій сесії `tmux` зі значенням семафора `2` (оптимізовано для MPS GPU) та буде логувати весь вивід у `logs/embeddings_local.log`.

#### Керування локальним сервісом

-   **Перегляд логів у реальному часі:**
    Підключіться до фонової сесії, щоб побачити живий вивід сервісу.
    ```bash
    ./scripts/manage.sh local logs
    ```
    *(Для відключення від перегляду логів натисніть `Ctrl-b` потім `d`)*

-   **Зупинка локального сервісу:**
    ```bash
    ./scripts/manage.sh local stop
    ```

-   **Перезапуск локального сервісу:**
    ```bash
    ./scripts/manage.sh local restart
    ```

## Продуктивність та управління семафором

Стабільність та продуктивність сервісу критично залежать від управління паралелізмом. Це досягається за допомогою `asyncio.Semaphore`.

### Конфігурація семафора
Семафор, визначений у `embeddings/app/app.py`, обмежує кількість одночасних запитів, що обробляються моделлю.

**Значення за замовчуванням:**
- **Docker CPU режим:** Оптимальне значення `8` (розраховане для 8 ГБ ОЗП, 4 ядер ЦП)
- **macOS GPU режим (MPS):** Поточне значення за замовчуванням `2` (підходить для локального GPU виконання)

```python
# embeddings/app/app.py
SEMAPHORE_VALUE = int(os.environ.get("SEMAPHORE_VALUE", "4"))  # За замовчуванням 4, локальний скрипт перевизначає на 2 для macOS GPU
```

### Результати продуктивності
- **Оптимізована продуктивність:** Система ефективно використовує ресурси ЦП/GPU залежно від режиму розгортання.
- **Стабільність пам'яті:** Споживання пам'яті оптимізовано для кожного режиму розгортання з відповідними значеннями семафора.

### Як налаштовувати семафор
`SEMAPHORE_VALUE` — це найважливіший параметр для налаштування продуктивності.

- **Docker CPU режим:** Використовуйте `8` для систем з 8 ГБ ОЗП та 4 ядрами ЦП.
- **macOS GPU режим:** Використовуйте `2` для оптимальної продуктивності MPS.
- **Коли змінювати:**
  - **Більше RAM:** Ви можете обережно спробувати збільшити значення (наприклад, до `10` або `12`), щоб потенційно підвищити пропускну здатність. Уважно стежте за використанням пам'яті.
  - **Менше RAM:** Якщо ви стикаєтеся зі збоями OOM, ви **повинні** зменшити це значення (наприклад, до `4` або `6`).
- **Як змінити:** Встановіть змінну середовища `SEMAPHORE_VALUE` або відредагуйте константу безпосередньо у файлі [`embeddings/app/app.py`](embeddings/app/app.py:1) та перезапустіть сервіс.

## Просунуті можливості

Сервіс ембедингів включає кілька просунутих функцій для оптимальної продуктивності та моніторингу:

### Очищення пам'яті на основі простою

Коли сервіс простоює 60 секунд, він автоматично запускає агресивне очищення пам'яті:
- Збирання сміття Python (`gc.collect()`)
- Очищення кешу PyTorch (MPS/CUDA)
- Звільнення пам'яті назад в ОС за допомогою `malloc_trim` (Linux/macOS)

### Логування статистики

Сервіс логуює агреговану статистику кожні 30 секунд під час активної роботи:
- Загальна кількість оброблених запитів
- Середній та максимальний час очікування
- Максимальна глибина черги

### Профілювання пам'яті

Вбудоване профілювання пам'яті з використанням `tracemalloc` надає детальний аналіз використання пам'яті для кожного запиту, допомагаючи виявляти та вирішувати проблеми з пам'яттю.

### Моніторинг здоров'я

Сервіс надає ендпоінт `/health` для моніторингу доступності сервіса.

## Споживання ресурсів (у простої)

Коли сервіси запущені, але не обробляють запити, їх базове споживання пам'яті становить:

-   **Сервіс ембедингів (Jina):** ~921 МіБ
-   **База даних Qdrant:** ~261 МіБ

### Споживання ресурсів під піковим навантаженням

Під час активної обробки споживання пам'яті може значно зростати:

-   **Сервіс ембедингів (Jina):** До ~2.5 ГіБ (з семафором=8 на ЦП)
-   **База даних Qdrant:** До ~400 МіБ

### Нотатки щодо продуктивності

- Споживання пам'яті масштабується зі значенням семафора та паралелізмом запитів
- Режими GPU (MPS/CUDA) зазвичай використовують менше пам'яті, ніж режим ЦП для еквівалентної пропускної здатності
- Механізми очищення на основі простою допомагають підтримувати базове споживання пам'яті

## Інтеграція з Visual Studio Code

Для максимальної зручності проєкт налаштований для керування прямо з VS Code за допомогою гарячих клавіш. Для цього необхідно налаштувати два файли в конфігурації VS Code.

### 1. Налаштування завдань (`tasks.json`)

Створіть або оновіть файл `tasks.json` у вашій користувацькій директорії налаштувань VS Code.

*   **Шлях на macOS:** `~/Library/Application Support/Code/User/tasks.json`
*   **Шлях на Windows:** `%APPDATA%\Code\User\tasks.json`
*   **Шлях на Linux:** `~/.config/Code/User/tasks.json`

Вставте в нього наступний вміст, **обов'язково замінивши** `$HOME/sandbox/mcp` на актуальний шлях до вашого проєкту:

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "startall + warmup",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "start", "all"]
    },
    {
      "label": "stopall",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "stop", "all"]
    },
    {
      "label": "restartall",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "restart", "all"]
    },
    {
      "label": "qdrant restart",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "restart", "qdrant"]
    },
    {
      "label": "jina start + warmup",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "start", "jina"]
    },
    {
      "label": "jina stop",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "stop", "jina"]
    },
    {
      "label": "local start",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "local", "start"]
    },
    {
      "label": "local stop",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "local", "stop"]
    },
    {
      "label": "local restart",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "local", "restart"]
    },
    {
      "label": "local logs",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "local", "logs"]
    },
    {
      "label": "local setup",
      "type": "shell",
      "command": "bash",
      "args": ["$HOME/sandbox/mcp/scripts/manage.sh", "local", "setup"]
    },
    {
      "label": "help: embeddings shortcuts",
      "type": "shell",
      "command": "echo",
      "args": [
        "-e",
        "\\033[1mJina/Qdrant — гарячі клавіші\\033[0m\\n\\n\\033[1mDocker режим:\\033[0m\\n  ⌘⇧9   startall + warmup      — Запустити Qdrant, Jina та прогріти ембединги\\n  ⌘⇧=   restartall            — Перезапустити всі сервіси\\n  ⌘⇧-   stopall               — Зупинити Jina та Qdrant\\n  ⌘⇧8   qdrant restart        — Перезапустити Qdrant\\n  ⌘⇧7   jina start + warmup   — Запустити Jina та прогріти\\n  ⌘⇧6   jina stop             — Зупинити Jina\\n\\n\\033[1mЛокальний режим (macOS GPU):\\033[0m\\n  ⌘⇧1   local start           — Запустити локальний embeddings сервіс\\n  ⌘⇧2   local stop            — Зупинити локальний сервіс\\n  ⌘⇧3   local restart         — Перезапустити локальний сервіс\\n  ⌘⇧L   local logs            — Перегляд логів локального сервісу\\n  ⌘⇧5   local setup           — Налаштувати локальне середовище\\n\\n  ⌘⇧0   help: embeddings shortcuts  — Показати цей екран\\n\\nПідказка: команди налаштовуються в User Tasks та Keyboard Shortcuts (JSON)."
      ],
      "presentation": {
        "reveal": "always",
        "panel": "dedicated",
        "clear": true
      },
      "problemMatcher": []
    }
  ]
}
```

### 2. Налаштування гарячих клавіш (`keybindings.json`)

Аналогічно, створіть або оновіть файл `keybindings.json`.

*   **Шлях на macOS:** `~/Library/Application Support/Code/User/keybindings.json`
*   **Шлях на Windows:** `%APPDATA%\Code\User\keybindings.json`
*   **Шлях на Linux:** `~/.config/Code/User/keybindings.json`

Вставте в нього наступний вміст:

```json
[
  {
    "key": "cmd+shift+9",
    "command": "workbench.action.tasks.runTask",
    "args": "startall + warmup"
  },
  {
    "key": "cmd+shift+=",
    "command": "workbench.action.tasks.runTask",
    "args": "restartall"
  },
  {
    "key": "cmd+shift+0",
    "command": "workbench.action.tasks.runTask",
    "args": "help: embeddings shortcuts"
  },
  {
    "key": "cmd+shift+-",
    "command": "workbench.action.tasks.runTask",
    "args": "stopall"
  },
  {
    "key": "cmd+shift+8",
    "command": "workbench.action.tasks.runTask",
    "args": "qdrant restart"
  },
  {
    "key": "cmd+shift+7",
    "command": "workbench.action.tasks.runTask",
    "args": "jina start + warmup"
  },
  {
    "key": "cmd+shift+6",
    "command": "workbench.action.tasks.runTask",
    "args": "jina stop"
  },
  {
    "key": "cmd+shift+1",
    "command": "workbench.action.tasks.runTask",
    "args": "local start"
  },
  {
    "key": "cmd+shift+2",
    "command": "workbench.action.tasks.runTask",
    "args": "local stop"
  },
  {
    "key": "cmd+shift+3",
    "command": "workbench.action.tasks.runTask",
    "args": "local restart"
  },
  {
    "key": "cmd+shift+l",
    "command": "workbench.action.tasks.runTask",
    "args": "local logs"
  },
  {
    "key": "cmd+shift+5",
    "command": "workbench.action.tasks.runTask",
    "args": "local setup"
  }
]
```

### Доступні команди (гарячі клавіші)

Після налаштування ви зможете керувати сервісами за допомогою наступних сполучень клавіш (для macOS, замініть `cmd` на `ctrl` для Windows/Linux):

#### Команди Docker режиму
| Гаряча клавіша | Команда                  | Опис                                           |
| --------------- | ------------------------ | -------------------------------------------------- |
| `⌘ + ⇧ + 9`     | `startall + warmup`      | Запустити Qdrant, Jina та прогріти ембединги        |
| `⌘ + ⇧ + =`     | `restartall`             | Перезапустити всі сервіси                          |
| `⌘ + ⇧ + -`     | `stopall`                | Зупинити Jina та Qdrant                           |
| `⌘ + ⇧ + 8`     | `qdrant restart`         | Перезапустити тільки Qdrant                        |
| `⌘ + ⇧ + 7`     | `jina start + warmup`    | Запустити тільки Jina та прогріти                    |
| `⌘ + ⇧ + 6`     | `jina stop`              | Зупинити тільки Jina                             |

#### Команди локального режиму (macOS GPU)
| Гаряча клавіша | Команда                  | Опис                                           |
| --------------- | ------------------------ | -------------------------------------------------- |
| `⌘ + ⇧ + 1`     | `local start`            | Запустити локальний embeddings сервіс              |
| `⌘ + ⇧ + 2`     | `local stop`             | Зупинити локальний сервіс                        |
| `⌘ + ⇧ + 3`     | `local restart`          | Перезапустити локальний сервіс                     |
| `⌘ + ⇧ + L`     | `local logs`             | Перегляд логів локального сервісу                  |
| `⌘ + ⇧ + 5`     | `local setup`            | Налаштувати локальне середовище                      |

#### Загальні команди
| Гаряча клавіша | Команда                  | Опис                                           |
| --------------- | ------------------------ | -------------------------------------------------- |
| `⌘ + ⇧ + 0`     | `help: embeddings shortcuts` | Показати цю довідку в терміналі VS Code           |
